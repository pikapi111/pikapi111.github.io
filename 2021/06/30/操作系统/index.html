

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>操作系统 - DAN</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="第一章 操作系统概述1）一个完整的计算机系统是由硬件系...">
  <meta name="author" content="dan">
  <link rel="icon" href="/images/icons/dan.jpg" type="image/png" sizes="16x16">
  
  
  
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_s6x2xcokxrl.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: '/images/theme/loading.gif'
      },
      donate: {
        enable: false,
        alipay: '',
        wechat: ''
      },
      galleries: {
        enable: false
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '[object Object]',
          api: 'https://source.unsplash.com/random/1920x1080'
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v1.hitokoto.cn/?encode=text&c=i',
          data_contents: ''
        },
      },
      qrcode: {
        enable: false,
        type: 'image',
        image: '',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
    </div>
    <div class="center">操作系统</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-wrap">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 相册</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright">歪比巴卜</div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/theme/5.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">操作系统</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>June 30, 2021</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>17538</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <h2 id="第一章-操作系统概述"><a href="#第一章-操作系统概述" class="headerlink" title="第一章 操作系统概述"></a>第一章 操作系统概述</h2><p>1）一个完整的计算机系统是由硬件系统和软件系统两大部分组成</p>
<p>2）计算机软件是指程序和与程序相关的文档的集合</p>
<p>3）按功能可把软件分为“系统软件”和“应用软件”两部分</p>
<p>系统软件：操作系统语言处理程序，数据库管理系统</p>
<p>应用软件：各种管理软件，用于工程计算的软件包，辅助设计软件</p>
<p>4）通常把未配置任何软件的计算机称为“裸机”</p>
<p>5）操作系统可以被看作是计算机系统的核心，统管整个系统资源，制定各种资源的分配策略，调度系统中运行的用户程序，协调它们对资源的需求，从而使整个系统在高效、有序的环境里工作。</p>
<p>6）发展的动力：</p>
<p>(1) 提高计算机资源的利用率的需要</p>
<p>(2) 方便用户使用计算机的需要</p>
<p>(3) 硬件技术不断发展的需要</p>
<p>(4) 计算机体系结构发展的需要</p>
<p>7）操作系统是在“裸机”上加载的第一层软件，是对计算机硬件系统功能的首次扩充</p>
<p>8）操作系统的定义：</p>
<p>操作系统是控制和管理计算机硬件和软件资源，合理地组织计算机工作流程，以及方便用户使用计算机的一个大型程序</p>
<p>9）操作系统的功能：</p>
<p>Ø 处理机管理：进程控制，进程同步，进程通信、调度、实施CPU分配</p>
<p>Ø 存储器管理：内存分配，内存保护，地址映射，内存扩充</p>
<p>Ø 设备管理：缓冲管理，设备分配，设备管理</p>
<p>Ø 文件管理：存储空间管理，目录管理，读写管理和保护</p>
<p>Ø 与用户有关的接口：用户接口，程序接口，人机交互</p>
<p>10）操作系统另一种定义：操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合</p>
<h3 id="操作系统的种类："><a href="#操作系统的种类：" class="headerlink" title="操作系统的种类："></a>操作系统的种类：</h3><ol>
<li>单道批处理系统</li>
</ol>
<p>特点：单路性、独占性、自动性、封闭性、顺序性</p>
<p>缺点：系统的资源得不到充分的利用</p>
<ol start="2">
<li>多道批处理系统</li>
</ol>
<p>特点：多路性、共享性、自动型、封闭性、无序性、调度性</p>
<p>好处：</p>
<p>ü 提高CPU的利用率</p>
<p>ü 提高内存和I/O设备的利用率</p>
<p>ü 增加系统吞吐量</p>
<p>缺点：平均周转时间长，无交互能力</p>
<ol start="3">
<li>分时系统</li>
</ol>
<p>分时系统是指在一台主机上连接了多个配有显示器和键盘的终端，由此所组成的系统，该系统允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机中的资源。</p>
<p>采用了“时间片轮转”的处理机调度策略</p>
<ol start="4">
<li>实时系统</li>
</ol>
<p>实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行</p>
<h2 id="第二章-处理机管理"><a href="#第二章-处理机管理" class="headerlink" title="第二章 处理机管理"></a>第二章 处理机管理</h2><ol>
<li><p>进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令，数据和堆栈等组成的，是一个能独立运行的活动实体，多个进程可以并发执行和交换信息</p>
</li>
<li><p>程序是一个在时间上严格有序的指令集合</p>
</li>
<li><p>在单道程序设计下，系统具有的特点</p>
</li>
</ol>
<p>a. 资源的独占性</p>
<p>b. 执行的顺序性</p>
<p>c. 结果的再现性</p>
<p>在多道程序设计环境下，系统具有：</p>
<p>a. 执行的并发性</p>
<p>b. 相互的制约性</p>
<p>c. 状态的多变性（不可再现性）</p>
<ol start="5">
<li>并发、并行、串行</li>
</ol>
<p>a. 从宏观上看是并行，同时在内存的多个程序都在执行着，互不影响</p>
<p>b. 从微观上看是串行，由于CPU在任何时刻只能执行一个程序，因此这些程序轮流占用CPU，交替执行着</p>
<p>c. 我们把“逻辑上相互独立的程序，在执行时间上相互重叠，一个程序的执行还没有结束，另一个程序的执行已经开始”的这种特性称为程序执行的并发性</p>
<ol start="6">
<li>对进程的描述</li>
</ol>
<p>a. 进程是程序的一次执行过程</p>
<p>b. 进程的运行活动是建立在某个数据集合上的</p>
<p>c. 进程是在获得资源的基础上从事自己的运行活动</p>
<ol start="7">
<li>进程的特征</li>
</ol>
<p>结构特征、动态性、并发性、独立性、异步性</p>
<p>进程是一个动态的概念</p>
<p>不同进程可以执行同一个程序</p>
<p>每一个进程都有自己的生命周期</p>
<p>进程之间具有并发性，进程间会相互制约</p>
<ol start="8">
<li>程序和进程的区别</li>
</ol>
<p>a. 程序是指令的有序集合，是静态的，进程是程序在处理机上的一次执行过程，是动态的。程序的存在时永久的，而进程是有生命周期的，它因创建而产生，因调度而运行，因撤销而消亡</p>
<p>b. 进程是程序的一次执行过程，程序是进程赖以存在的基础</p>
<p>c. 进程具有并发性，而程序并发执行会失去可再现性</p>
<p>d. 进程是系统分配和调度的独立单位，进程由程序、数据集合和进程控制块组成</p>
<ol start="9">
<li><p>系统进程的使用级别高于用户进程</p>
</li>
<li><p>进程的状态</p>
</li>
</ol>
<p>创建、就绪、运行、阻塞</p>
<p>a. 一个进程从运行状态变为就绪状态，一定会引起另一个进程从就绪变为运行</p>
<p>b. 一个进程从运行状态变为阻塞状态，一定会引起另一个进程从运行状态变为就绪状态；这种因果变迁绝对不可能发生，因为一个CPU不可能真正同时运行两个进程</p>
<p>c. 一个进程从阻塞状态变为就绪状态，不一定会引起另一个进程从就绪状态变为运行状态</p>
<ol start="11">
<li><p>进程的三个组成部分：程序、数据集合、进程控制块（PCB）</p>
</li>
<li><p>进程控制块是进程存在的唯一标示</p>
</li>
</ol>
<p>a. 作用：通过PCB，是原来不能独立运行的程序，成为一个可以独立运行的基本单位，一个能够并发执行的进程</p>
<p>b. 其中的信息：进程标识符、处理机状态、进程调度信息、进程控制信息</p>
<ol start="13">
<li><p>操作系统中把做出“决定把CPU分配给谁用”的程序称为“进程调度程序”</p>
</li>
<li><p>常用的进程调度算法：</p>
</li>
</ol>
<p>a. 先来先服务调度算法</p>
<p>b. 时间片轮转调度算法：为就绪队列中的每一个进程分配一个称为“时间片”的时间段，它是允许该进程占用CPU的最长时间长度</p>
<p>c. 优先数调度算法：优先数高的先调度，若相同则先来先服务</p>
<p>d. 多级队列调度算法：时间片调度和优先数调度算法的结合</p>
<ol start="15">
<li>进程调度程序的主要功能</li>
</ol>
<p>a. 记录系统中所有进程的有关情况，比如进程的当前状态，优先数等</p>
<p>b. 确定分配处理机的算法</p>
<p>c. 完成处理机的分配</p>
<p>d. 完成处理机的回收</p>
<ol start="16">
<li><p>把处理剂分配给进程后，还有一个允许它占用多长时间的问题，有两种处理方式，一种是不可剥夺方式，另一种是剥夺方式</p>
</li>
<li><p>为了对进程进行有效的管理和控制，操作系统要提供若干基本的操作以便能创建进程、撤销进程、阻塞进程、唤醒进程，把具有这种特性的程序称为“原语”，原语的不可分割性，通常利用屏蔽中断的方法</p>
</li>
<li><p>程序接口：操作系统在程序一级给予用户的支持</p>
</li>
</ol>
<p>命令接口：操作系统在控制一级给予用户的支持</p>
<ol start="19">
<li>CPU指令系统中的指令分为两类</li>
</ol>
<p>a. 操作系统和用户都能使用的指令，非特权指令</p>
<p>b. 只能由操作系统使用的指令，特权指令</p>
<ol start="20">
<li>CPU的两种工作状态：管态、目态</li>
</ol>
<p>a. 当CPU处于管态时，可以执行包括特权指令在内的一切机器指令</p>
<p>b. 当CPU处于目态时，禁止使用特权指令</p>
<ol start="21">
<li>访管指令</li>
</ol>
<p>系统调用命令的程序属于操作系统，它应该在管态下执行</p>
<p>用户程序只有通过计算机系统提供的访管指令才能实现由目态转为管态，进而调用这些功能程序的目的</p>
<p>访管指令属于非特权指令，功能是执行它就会产生一个软中断，促使中央处理机由目态转为管态，进入操作系统并处理该中断</p>
<ol start="22">
<li>从功能上看，可以把系统调用命令分为五大类：</li>
</ol>
<p>a. 一是关于进程管理和控制的</p>
<p>b. 二是关于外部设备输入/输出的</p>
<p>c. 三是关于磁盘文件管理的</p>
<p>d. 四是关于访问系统信息的</p>
<p>e. 五是关于存储申请与释放的</p>
<ol start="23">
<li>从形式上看，操作系统提供的系统调用与一般的过程调用（子程序调用）相似，但它们有着明显 的区别</li>
</ol>
<h3 id="作业管理："><a href="#作业管理：" class="headerlink" title="作业管理："></a>作业管理：</h3><ol>
<li><p>把一个作业提交给系统时，系统要开辟一个作业控制块JCB，以便随时记录作业的信息</p>
</li>
<li><p>被系统接纳的作业，在没有投入运行之前，称为后备作业。这些作业存放在辅助存储器中，并由他们的JCB连接在一起，形成所谓的后备作业队列</p>
</li>
<li><p>作业调度：按照某种规则，从后备作业队列中挑选作业进入内存，参与处理机的竞争，这个过程称为作业调度</p>
</li>
<li><p>作业的状态：</p>
</li>
</ol>
<p>a. 提交状态：进入辅助存储器，作业的信息还没有全部进入系统，系统也没有为它建立JCB，感知不到它的存在</p>
<p>b. 后备状态：建立起了JCB，并将JCB排到后备作业队列中</p>
<p>c. 运行状态：（阻塞、运行、就绪）都属于运行状态</p>
<p>d. 完成状态：也是一个暂时性的状态</p>
<ol start="5">
<li>作业的调度算法：</li>
</ol>
<p>a. 先来先服务：以作业进入后备作业队列的先后次序</p>
<p>周转时间=完成时间-到达时间</p>
<p>注：若分配一定的内存，且不允许作业在内存中移动时，要考虑所占内存大小</p>
<p>b. 短作业优先：从后备作业队列中挑选所需CPU时间最少且资源能够得到满足的作业</p>
<p>注：如果所有作业“同时”到达后备作业队列，那么采用短作业优先的作业调度算法总会获得最小的平均周转时间</p>
<p>c. 响应比高着优先：先调度响应比高着   </p>
<p>响应比=已等待时间/所需CPU时间</p>
<ol start="6">
<li>在确定作业调度算法时应注意的问题：</li>
</ol>
<p>a. 公平对待后备作业队列中的每一个作业，避免无故或无限期的延迟一个作业的执行，使各类用户感到满意</p>
<p>b. 使进入内存的多个作业，能均衡地使用系统中的资源，避免出现有的资源没有作业使用，有的资源却被多个作业争抢的“忙闲”不均的情况</p>
<p>c. 力争在单位时间内为尽可能多的作业提供服务，提高整个系统的吞吐能力</p>
<h2 id="第三章-存储管理"><a href="#第三章-存储管理" class="headerlink" title="第三章 存储管理"></a>第三章 存储管理</h2><ol>
<li><p> 计算机操作系统的存储器：CPU寄存器，主存，辅存</p>
</li>
<li><p>在考虑计算机存储器的设计时，必须顾及</p>
</li>
</ol>
<p>a. 价格、容量、访问时间</p>
<p>b. 存取时间越快，价格越高，容量越小</p>
<ol start="3">
<li>高速缓存：介于寄存器和存储器之间的存储器，主要用于备份主存中较常用的数据，以减少处理机对主存储器的访问次数，提高程序执行速度</li>
</ol>
<p>高速缓存容量远大于寄存器，比内存约小两到三个数量级左右</p>
<p>为了缓和内存与处理机（CPU）速度的不匹配</p>
<ol start="4">
<li>字（字长）：一次传送数据的长度{16、32、64…}依系统而定</li>
</ol>
<p>（主）内存储器和高速缓存之间是以“块”为单位传递数据的</p>
<p>高速缓存与CPU之间则以“字”为单位传递数据</p>
<ol start="5">
<li>存储器管理的功能：</li>
</ol>
<p>a. 内存的分配与回收</p>
<p>b. 存储的保护和共享</p>
<p>c. 地址定位</p>
<p>d. 存储扩充</p>
<ol start="6">
<li><p>内存储器由一个个存储单元组成，一个存储单元可存放若干个二进制的位（bit），8个二进制位被称为一个字节（byte）</p>
</li>
<li><p>在操作系统中，把用户程序指令中的相对地址变为所在绝对地址空间中的绝对地址的这个过程，称为地址重定位</p>
</li>
<li><p>地址的定位方式：</p>
</li>
</ol>
<p>a. 绝对定位方式：是在程序装入内存之前，程序指令中的地址就已经是绝对地址，已经正确地反映了它将要进入的存储区的位置，不适用于多道程序设计环境</p>
<p>b. 静态重定位（多道程序环境下）</p>
<p>根据内存的具体情况将装入模块装入到内存的适当位置，会使装入模块中的所有逻辑地址与实际装入内存后的物理地址不同。</p>
<p>这种地址重定位是在程序执行前完成的</p>
<p>c. 动态重定位</p>
<p>将地址重定位的时间推迟到程序执行时再进行</p>
<p>所以装入内存的所有地址都仍是逻辑地址</p>
<p>连续分配存储方式 ：</p>
<ol>
<li>单一连续分配（静态重定位）</li>
</ol>
<p>a. 单道程序环境下，总体上把内存储器分为两个分区：系统区和用户区</p>
<p>b. 系统总是把整个用户区分配给一个用户使用，把分配给了用户但未被使用的区域称为“内部碎片”</p>
<p>c. 单一连续分区存储管理的缺点：</p>
<p>a) 由于每次只能有一个进入内存，故它不适用于多道程序设计，工作效率不高，资源利用率低</p>
<p>b) 只要作业比用户区小，在用户区里就会形成碎片，造成资源浪费</p>
<p>c) 大作业无法在小内存中运行</p>
<p>d. 为缓解大作业小内存的情况提出覆盖技术和对换技术</p>
<p>a) 覆盖技术：允许一个作业的若干个程序段使用同一个存储区</p>
<p>b) 对换技术：以辅助存储器作为内存的后援（硬盘）</p>
<ol start="2">
<li>固定分区存储管理（静态）：分区数目、大小固定</li>
</ol>
<p>a. 预先把内存储器中可供分配的用户区划分成若干个连续分区，每个分区的尺寸可以相同，可以不同。每个分区中只允许装入一个作业运行，系统可以为每一个分区设置一个后备作业队列，一个作业到达时，总是进入到“能容纳该作业的最小分区”的那个后备队列中去排队</p>
<p>b. 分区的分配与释放方案：</p>
<p>a) 在队列中挑选出第一个可容纳的作业进入</p>
<p>i. 优点：选择效率高</p>
<p>ii. 缺点：小作业-&gt;大内存</p>
<p>b) 在这个队列中进行搜索，找到这个分区能够容纳的最大的那个作业，让它进入运行</p>
<p>i. 优点：存储空间利用率高，产生内部碎片尽可能的小</p>
<p>ii. 缺点：选择效率低</p>
<p>c) 在系统中至少保留一个小的分区，以避免因为运行小作业而被迫分配打分去的发生</p>
<p>d) 为具体管理各个分区，并建立一个“分区分配表”，其中包括每个分区的起始位置大小及状态</p>
<p>c. 特点</p>
<p>a) 它是最简单的，具有“多道”色彩的存储管理方案，提高资源利用率</p>
<p>b) 当把一个分区分配给某个作业时，该作业的程序将一次性的全部装入到分配给他的连续分区里</p>
<p>c) 静态重定位，在分区内的程序不能随意移动</p>
<p>d. 缺点</p>
<p>a) 进入分区的作业尺寸不见得与分区的长度相吻合，势必产生内部碎片，引起资源的浪费</p>
<p>b) 如果到达作业的尺寸比任何一个分区的长度都大，它就无法运行</p>
<ol start="3">
<li>可变分区存储管理：</li>
</ol>
<p>分区的边界划分随作业的需求可变，分区的数目随着进入作业的多少可变，消灭了内部碎片（可能会产生内部碎片）。</p>
<p>外部碎片是指无法分配给用户使用的存储区</p>
<p>a. 基本思想：在作业要求装入内存储器时，如果当时内存储器中有足够的存储空间满足该作业的需求，就划分出一个与作业相对地址空间同样大小的分区，并分配给它</p>
<p>b. 要解决的问题</p>
<p>a) 采用一种新的地址重定位技术，动态地址重定位，以便程序能够在内存储器中随意移动，为空闲区的合并提供保证</p>
<p>b) 记住系统中各个分区的使用情况</p>
<p>c) 给出分区分配算法</p>
<p>c. 地址动态重定位过程（在程序执行时动态完成）</p>
<p>a) 为实施地址动态重定位，硬件要增加一个地址转换机构，这个机构一般由地址转换线路和一个定位寄存器（基址寄存器）组成</p>
<p>b) 地址的静态重定位和动态重定位的比较</p>
<p>i. 地址转换时刻：静态重定位是在程序运行之前完成地址转换的，而动态重定位是在程序执行时完成</p>
<p>ii. 谁来完成任务：静态重定位是由软件完成地址转换工作的，而动态重定位则是由一套硬件提供的地址转换机构来完成</p>
<p>iii. 完成的形式：静态重定位是在装入时一次性集中地把程序指令中所有要转换的地址加以转换；而动态重定位则是每执行一条执行时，就对其地址加以转换</p>
<p>iv. 完成的结果：实施静态重定位，原来的指令地址部分被修改了，而动态重定位只是按照所形成的地址去执行这条指令，并不对指令本身做任何修改</p>
<p>d. 空闲区的合并</p>
<p>e. 分区的管理</p>
<p>a) 表格法：一张已分配表，一张空闲表（分区号，分区大小，分区起始地址、状态）</p>
<p>b) 单链表法：一个存放该分区的长度，另一个存放它下一个空闲分区的起始地址</p>
<p>c) 双链表法：还存放上一个空闲区起始地址</p>
<p>f. 空闲分区的分配算法</p>
<p>a) 最先适应算法：要求空闲分区链以地址递增的次序链接（对大作业不利）</p>
<p>b) 最佳适应算法：每次为作业分配内存时，总是把能满足要求，又是最小的空闲分区分配给作业，避免“大材小用” 按其容量</p>
<p>c) 最坏适应算法：挑选一个最大的空闲区，从中分割一部分存储空间给作者使用，以至于存储器中缺乏大的空闲分区，照顾中小作业的需求</p>
<p>d) 循环首次适应算法：从上次分配的位置之后开始查找</p>
<p>g. 可变分区存储管理的特点</p>
<p>a) 作业一次性的全部装入到一个连续的存储分区中</p>
<p>b) 分区是按照作业对存储的需求划分的，所以不会出现内部碎片</p>
<p>c) 为了确保作业能够在内存中移动，要有硬件的支持，实行指令地址的动态重定位</p>
<p>h. 缺点：</p>
<p>a) 仍然没有解决小内存裕兴大作业的问题，只要作业的存储需求大于系统提供的整个用户区，该作业就无法投入运行</p>
<p>b) 虽然避免了内部碎片，但有可能出现极小的翻去暂时分配不出去的情形，引起了外部碎片，</p>
<p>c) 为了形成大的分区，可变分区存储管理通过移动程序来达到分区合并的目的，然而程序的移动是很花费时间的，增加了系统在这方面的投入与开销</p>
<ol start="4">
<li>分页式存储管理：</li>
</ol>
<p>需要两次访问内存，目的是提高内存利用率</p>
<p>a. 分页式储存管理是将固定分区方法与动态重定位技术结合在一起，需要硬件支持</p>
<p>基本思想：首先把整个内存储器划分成大小相等的许多分区，每个分区称为“一块”</p>
<p>b. 在分页式存储管理中，块是存储分配的单位</p>
<p>a) 用户作业仍然是相对于“0”进行编址，形成一个连续的相对地址空间</p>
<p>b) 用户程序相对地址空间中的每一个分区被称为“页”，用户相对地址空间中的每一个相对地址，都可以用（页号，页内位移）这样的数对来表示</p>
<p>i. 物理地址=页的大小*页号+页内位移</p>
<p>ii. 页号=相对地址/块尺寸</p>
<p>iii. 页内位移=相对地址%块尺寸</p>
<p>c. 页与块对应关系表称为“页表”</p>
<p>a) 快速寄存器组单独起名为“相联寄存器”，简称“快表”</p>
<p>b) 快表与页表联合工作，先查找快表，若无再查找页表并把数据写入快表</p>
<p>c) （访问页表时间+访问一次内存时间）<em>命中率+访问快表时间</em>命中率=平均内存存取时间</p>
<p>d) 页面尺寸大多选在512byte到64kb之间</p>
<p>d. 特点：</p>
<p>a) 内存储器实现被划分成相等尺寸的块，它是进行存储分配的单元</p>
<p>b) 用户作业的相对地址空间按照块的尺寸划分成页，这是在系统内部进行的，用户感觉不到</p>
<p>c) 相对地址空间中的页可以进入内存中的任何一个空闲块，并且分页式存储管理实行的是动态重定位，因此它打破了一个作业必须占据连续的存储空间的限制，作业在不连续的存储区里，也能够得到正确的运行</p>
<p>e. 缺点：</p>
<p>a) 平均每一个作业要浪费半页大小的存储块，会产生内部碎片</p>
<p>b) 作业虽然可以不占据连续的存储区，但是每次仍然要求一次全部进入内存。因此，如果作业很大，其存储需求大于内存，仍然存在小内存不能运行大作业的问题</p>
<ol start="5">
<li>分段式存储管理：</li>
</ol>
<p>a. 目的：方便用户使用编程，存储共享，存储保护，动态增长，动态链接</p>
<p>b. 要求用户将自己的整个作业程序以多个相互独立的称为“段”的地址空间提交给系统，每个段都是一个从“0”开始的一维地址空间，长度不一，操作系统按照段长为作业分配内存空间</p>
<p>c. 段表：段号、段长、该段在内存的基址（起始地址）{段号，段内位移}</p>
<p>a) 物理地址=段的起始地址+段内地址</p>
<p>b) 逻辑地址=段号+段内地址</p>
<p>d. 分段与分页的区别：</p>
<p>a) 页是信息的物理单位，段是信息的逻辑单位</p>
<p>i. 分页提高内存的利用率，仅仅是系统管理上的需要，用户不可见。段是信息的逻辑单位，它通常包括的是一组意义相对完整的信息，分段段的目的主要在于能更好地满足用户的需要</p>
<p>b) 页的尺寸由系统决定，段的尺寸因段而异</p>
<p>i. 段的长度取决于用户编写的程序，通常由编译程序在对源程序进行编译时根据信息的性质来划分</p>
<p>c) 页的地址空间是一维的，段的地址空间是二维的</p>
<p>i. 分页：用户必须通过链接编辑程序，把各程序段链接成一个相对于0编址的线性空间，程序中是通过地址编号来确定空间中的位置的。因此用户向系统提供的是一个一维的逻辑地址空间。</p>
<p>ii. 分段：用户不把各程序段链接成一个相对于0进行编制的一维线性空间，各程序段之间是通过{段号，段内位移}进行访问的。因此，用户向系统提供的是一个二维的逻辑地址空间</p>
<ol start="6">
<li>段页式存储管理：（三次访问内存）</li>
</ol>
<p>a. 基本原理：分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。</p>
<p>a) 作业地址空间结构：主程序段，子程序段，数据段</p>
<p>b) 地址结构：段号，段内页号，页内地址</p>
<p>b. 系统设置了位示图、段表和页表，记录主存的使用情况和作业分配情况</p>
<p>a) 逻辑地址=段号+页号+页内位置</p>
<p>b) 块号*块长+页内地址</p>
<p>c. 虚拟存储器：是具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统，其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度。</p>
<p>a) 特征：多次性、对换性、虚拟性、离散性</p>
<p>d. 请求分页式存储管理（需要硬件支持）</p>
<p>a) 是基于分页式存储管理的一种虚拟存储器</p>
<p>“请求分页式”是指当程序运行中需要某一页时，再把它从辅助存储器里调入内存使用，解决了小内存与大作业的矛盾，但会产生内部碎片</p>
<p>b) 缺页中断是指在指令执行期间，若发现所要访问的指令或数据不在内存时，便立即产生和处理缺页中断信号，以便能及时将所缺之页面调入内存</p>
<p>e. 缺页中断与一般中断的区别 {缺页中断率=缺页次数/页面总数}</p>
<p>a) 缺页中断是在执行一条指令中间时产生的中断，并立即去处理，一般中断则是一条指令执行完毕后，当发现有中断请求时，才去响应和处理</p>
<p>b) 缺页中断处理完成后，仍返回到原指令去执行，因为那条指令并未执行；而一般中断则是到下一条指令去执行，因为上一条指令已经执行完毕了</p>
<p>f. 影响缺页中断次数的因素：</p>
<p>a) 分配给作业的内存块数</p>
<p>b) 页面尺寸</p>
<p>c) 程序的实现</p>
<ol start="7">
<li>页面淘汰（置换）算法：</li>
</ol>
<p>页面淘汰是由缺页中断引起的，但缺页中断不见得一定引起页面淘汰</p>
<p>a. 先进先出页面淘汰（置换）算法（FIFO）</p>
<p>淘汰最先进入内存的页面 （3个内存块都为空，3次缺页中断）</p>
<p>b. 最近最久未用页面淘汰（置换）算法（LRU）</p>
<p>总是把最长时间未被访问过的页面淘汰出去 （需要寄存器和栈）</p>
<p>c. 最近最少用页面淘汰（置换）算法（LFU）</p>
<p>总是把当前使用的最少的页面淘汰出去</p>
<p>为每个内存中的页面设置一个计数器（移位寄存器） 加1</p>
<p>d. 最优（最佳）页面淘汰（置换）算法（OPT）</p>
<p>把以后不再使用的或最长时间内不会用到的页面淘汰出去（理论上，不会实现）</p>
<p>注：对于FIFO页面淘汰算法，有时增加分配给作业的可用内存块数，它的缺页次数反而上升，通常称为异常现象</p>
<h2 id="第四章-设备管理"><a href="#第四章-设备管理" class="headerlink" title="第四章 设备管理"></a>第四章 设备管理</h2><p>1．“设备”泛指计算机系统中的各种外部设备，外设（即主机以外的其他所有设备）在众多的I/O设备中，并不是所有的设备都是可以共享的，可以借助于磁盘，把只能独享的设备变为共享，这就是所谓的“虚拟设备” {SPOOLing技术}</p>
<p>2．设备是指计算机中用以在机器之间进行传送和接收信息，完成用户输入/输出（I/O）操作的那些部件。比如磁盘、磁带、打印机、显示器、鼠标、键盘······</p>
<p>3．计算机I/O系统的组织结构：</p>
<p>（1）底层是具体的设备和硬件接口</p>
<p>（2）中间是系统软件（与设备相关软件、与设备无关软件）</p>
<p>（3）用户程序</p>
<p>4．I/O设备一般是由执行I/O操作的机械部分和执行控制I/O的电子部件组成</p>
<p>（1）执行I/O操作的机械部分就是一般的I/O设备</p>
<p>（2）执行控制I/O的电子部件称为设备控制器或适配器</p>
<p>① 为了能够使CPU设备控制器中的各个寄存器进行通信，通常采用“单独的I/O空间”和“内存映射I/O”两种方法</p>
<p>② 设备控制器是CPU与外围设备之间的接口，是一个可编址设备，每一个地址对应一个设备</p>
<p>功能：</p>
<p>Ø 接收和识别命令</p>
<p>Ø 数据交换</p>
<p>Ø 标识和报告设备的状态</p>
<p>Ø 地址识别</p>
<p>Ø 数据缓冲区</p>
<p>Ø 差错控制</p>
<p>组成：</p>
<p>Ø 设备控制器与处理机（CPU）的接口</p>
<p>Ø 设备控制器与设备的接口</p>
<p>Ø I/O逻辑：用于实现对设备的控制</p>
<p>5．设备驱动程序：</p>
<p>6．设备处理方式：</p>
<p>（1）为每一类设备设置一个进程，专门用于执行这类设备的I/O操作</p>
<p>（2）在整个系统中设置一个I/O进程，专门用于执行系统中所有各类设备的I/O操作</p>
<p>（3）不设置专门的设备处理进程，而只为各类设置相应的设备驱动程序，供用户或系统进程调用</p>
<p>7．设备驱动程序的处理过程</p>
<p>（1）将抽象要求转换为具体要求</p>
<p>（2）对服务请求进行校验，即检查I/O请求的合法性</p>
<p>（3）检查设备的状态</p>
<p>（4）传送必要的参数</p>
<p>（5）启动I/O设备</p>
<p>（6）工作方式的设置</p>
<p>I/O接口程序：是操作系统中与设备无关的软件，它从上层接收用户对设备提出的I/O请求，然后负责吧I/O请求转变成所需要的I/O命令，调用具体的设备驱动程序去执行</p>
<p>系统都是用主设备号和次设备号组成“逻辑设备名”</p>
<p>操作系统提供的设备无关性的优点：</p>
<p>ü 方便用户</p>
<p>ü 提高设备的利用率</p>
<p>8．计算机设备的分类</p>
<p>（1）基于设备的从属关系</p>
<p>a. 系统设备（键盘、显示器、打印机、磁盘驱动）</p>
<p>b. 用户设备</p>
<p>（2）基于设备的分配特性</p>
<p>a. 独享设备（打印机）</p>
<p>b. 共享设备</p>
<p>c. 虚拟设备（SPOOLing技术）</p>
<p>（3）基于设备的工作特性</p>
<p>a. 输入/输出设备（字符设备）</p>
<p>b. 存储设备（块设备） 磁盘、磁带</p>
<p>（4）按信息交换的单位</p>
<p>a. 块设备：用于存储信息，属于结构设备。磁盘、磁带（以块为单位传送信息）</p>
<p>b. 字符设备：以单个字符为单位来传送信息。 键盘</p>
<p>9．设备管理的目标</p>
<p>a. 提高外部设备的利用率</p>
<p>b. 为用户提供便利、统一的使用界面</p>
<p>10．设备管理的功能</p>
<p>a. 提供一组I/O命令</p>
<p>b. 进行设备的分配和回收</p>
<p>c. 对缓冲区进行管理</p>
<p>d. 实现真正的I/O操作</p>
<p>11．输入输出管理步骤</p>
<p>（1）用户在程序中使用系统提供的输入/输出命令发出I/O请求</p>
<p>（2）输入输出管理程序接受这个请求</p>
<p>（3）“设备驱动程序”来具体完成所要求的的I/O操作</p>
<p>（4）实现设备中断处理程序来处理这个请求</p>
<p>设备的输入输出管理程序由3块内容组成：接受用户的I/O请求，组织管理输入输出进行，输入输出的善后处理</p>
<p>设备控制：</p>
<ol>
<li><p>设备控制块DCB中存放的是一台具体设备的有关信息，找到一个设备的DCB，就得到了该设备的特性，各种参数，使用情况等，所以DCB是设备管理中最重要的一条数据结构</p>
</li>
<li><p>独享设备中具有排他性，只能采取“静态分配”的策略</p>
</li>
</ol>
<p>a. 静态分配：用户作业开始之前，由系统一次分配给该作业所需的设备，控制器和通道，不会发生死锁</p>
<p>b. 动态分配：在进程执行过程中进行的设备分配，可能造成死锁</p>
<p>对独享设备采用的分配算法：</p>
<p>v 先来先服务</p>
<p>v 优先级高者先服务</p>
<ol start="3">
<li>共享磁盘的调度</li>
</ol>
<p>磁盘是一种典型的共享存储设备，允许多个作业进程同时使用，而不是让一个作业在整个运行期间独占。“同时使用”是指当一个作业进程暂时不用时，其他作业进程就可以使用。每一个时刻只有一个作业用</p>
<ol start="4">
<li>调度算法</li>
</ol>
<p>a. “先来先服务”调度算法（并不理想）（移臂调度，减少查找时间）</p>
<p>以I/O请求到达的先后次序作为磁盘调度的顺序</p>
<p>b. “最短查找时间”调度算法</p>
<p>把距离磁头当前位置最近的I/O请求作为下一次调度的对象</p>
<p>c. “电梯”调度算法（SCAN）</p>
<p>总是沿着此案移动臂的移动方向选择距离磁头当前位置最近的I/O请求，作为下一次调度的对象</p>
<p>d. “单向扫描”调度算法（循环扫描 CSCAN）</p>
<p>总是从0号柱面开始往里移动移动臂，遇到有I/O请求就进行处理，直到到达最后一个请求柱面，然后移动臂立即带动磁头不做任何服务地快速返回到0号柱面，开始下一次扫描</p>
<p>对I/O设备的控制方式（数据传输方式）</p>
<ol>
<li>程序循环测试方式（程序查询式）</li>
</ol>
<p>是指用户进程使用start指令启动设备后，不断地执行test指令，去测试所启动设备的状态寄存器。只有在状态寄存器出现了所需要的状态后，才停止测试工作，完成输入/输出。</p>
<p>数据寄存器：用来存放传输的数据</p>
<p>状态寄存器：用来记录设备当前所处状态</p>
<ol start="2">
<li>中断方式</li>
</ol>
<p>所谓“中断”是一种使CPU暂时中止正在执行的程序而转去处理特殊时间的操作。</p>
<p>引起中断的时间称为中断源。</p>
<p>程序中产生的中断，由CPU的某些错误结果（如，计算机溢出）产生的中断称为“内中断”，由外部设备控制器引起的中断称为“外中断”</p>
<ol start="3">
<li>直接存储器存取方式（DMA方式）</li>
</ol>
<p>特点：能使I/O设备直接和内存储器进行成批数据的快速传输。（单位：块数据）</p>
<p>DMA控制器包括四个寄存器：数据寄存器，状态寄存器，地址寄存器，字节计数器</p>
<p>DMA控制器的组成：主机与DMA控制器的接口；DMA控制器与块设备的接口；I/O控制逻辑</p>
<ol start="4">
<li>通道方式</li>
</ol>
<p>通道方式能够使CPU彻底从I/O中解放出来。CPU进行善后处理和启动。</p>
<p>通道是一个独立于CPU的，专门用来管理输入/输出操作的处理机。</p>
<p>通道是通过执行通道程序并与设备控制器共同实现对I/O设备的控制的。</p>
<p>它规定了设备应该执行的各种操作的顺序。由一系列通道指令所构成，CPU对I/O请求只去做启动和善后处理工作，输入/输出的管理以及数据传输等事宜，全部由通道独立完成。</p>
<p>缓冲：</p>
<ol>
<li>原因：</li>
</ol>
<p>a. 缓和CPU与I/O设备间速度不匹配的矛盾</p>
<p>b. 减少对CPU的中断频率，放宽对CPU中断响应时间的限制</p>
<p>c. 解决数据粒度不匹配的问题</p>
<p>d. 提高CPU和I/O设备之间的并行性</p>
<ol start="2">
<li>缓冲的实现</li>
</ol>
<p>a. 采用专门的硬件寄存器，比如设备控制器里的数据寄存器，“硬件缓冲”</p>
<p>b. 在内存储器中开辟出n个单元，作为专用的I/O缓冲区，以便存放输入/输出的数据，这种缓冲区就是“软件缓冲”</p>
<p>c. 根据缓冲区的个数：单缓冲区、双缓冲区、多缓冲区、缓冲池</p>
<ol start="3">
<li>虚拟设备</li>
</ol>
<p>a. 通过多道程序技术可将一台物理CPU虚拟为多台逻辑CPU，需要硬件的支持。作为后援的硬盘（大容量），具有设备与CPU并行工作的能力</p>
<ol start="4">
<li>SPOOLing技术</li>
</ol>
<p>a. 在主机的直接控制下，实现以前的脱机输入/输出功能，此时的外围操作与CPU对数据的处理同时进行，我们把这种在联机情况下实现的同时外围操作的技术称为SPOOLing技术，或假脱机技术</p>
<p>b. SPOOLing技术是对脱机输入/输出系统的模拟。SPOOLing系统建立在通道技术和多道程序技术的基础上，以高速随机外存（通常为磁盘）为后援存储器</p>
<ol start="5">
<li>设备无关性：</li>
</ol>
<p>应用程序中所用的设备，不局限于使用某个具体的物理设备。为每个设备所配置的设备驱动程序是与硬件紧密相关的软件。为了实现设备独立性，必须再在设备驱动程序上设置一层软件，称为与设备无关的I/O软件或设备独立性软件</p>
<ol start="6">
<li>操作系统中实现虚拟设备的软件功能模块由3部分组成</li>
</ol>
<p>a. 预输入程序</p>
<p>b. 缓输出程序</p>
<p>c. 井管理程序</p>
<ol start="7">
<li>SPOOLing系统由四部分组成</li>
</ol>
<p>a. 输入井和输出井</p>
<p>在磁盘上开辟出来的两个存储区域，输入数据，输出数据</p>
<p>b. 输入缓冲区和输出缓冲区</p>
<p>在内存中开辟的两个缓冲区</p>
<p>c. 输入进程和输出进程</p>
<p>模拟外围控制机</p>
<p>d. 井管理程序</p>
<p>特点：</p>
<p>Ø 提高了I/O的速度</p>
<p>Ø 将独占设备改造为共享设备</p>
<p>Ø 实现了虚拟设备的功能</p>
<h2 id="第五章-文件管理"><a href="#第五章-文件管理" class="headerlink" title="第五章 文件管理"></a>第五章 文件管理</h2><ol>
<li>目标：提高外存储空间的利用率</li>
</ol>
<p>主要任务：对用户文件和系统文件进行管理，方便用户使用，并保证文件的安全性</p>
<p>文件存储设备是以块为单位进行管理的</p>
<ol start="2">
<li><p>所谓“文件”是指具有完整逻辑意义的一组相关信息的集合，它是在磁盘上保存信息，而且能方便以后读取的方法，文件用符号名加以标识，这个符号名就被称为“文件名”</p>
</li>
<li><p>文件是指由创建者所定义的，具有文件名的一组相关元素的集合，可分为有结构文件和无结构文件两种。在有结构的文件中，文件由若干个相关记录组成而无结构文件则被看成是一个字符流。文件在文件系统中是一个最大的数据单位，它描述了对象集</p>
</li>
</ol>
<p>文件属性：文件类型、文件长度、文件的物理位置、文件的建立时间（最后一次的修改时间）</p>
<ol start="4">
<li><p>文件名：在不同的系统之间，对文件名的规定是不同的。一个文件名是在创建该文件时由用户给出的，操作系统将向用户提供组成文件名的命名规则</p>
</li>
<li><p>很多操作系统采用句点‘.’隔开成两部分的文件名形式，句点之前的部分称为文件名，句点后面的部分称为文件的“扩展名”。又称后缀名，用于指示文件的类型</p>
</li>
</ol>
<p>.bak 备份文件 .bas ABSIC源程序 .bin 可执行的二进制文件</p>
<p>.c C源程序 .dat 数据文件 .doc 文档文件</p>
<p>.hlp 帮助文件 .obj 目标文件 .pas Pascal文件</p>
<p>.txt 一般文本文件 .tmp 临时文件</p>
<ol>
<li><p>文件被存在大容量的辅助存储器（外存）中，当用户需要使用时，就通过文件名把相应的文件读到内存</p>
</li>
<li><p>“文件系统”是指操作系统中与文件管理有关的那部分软件，被管理的文件，以及管理文件所需要的数据结构（目录、索引表······）的总体</p>
</li>
<li><p>对文件的分类</p>
</li>
</ol>
<p>a. 按文件的性质和用途：系统文件、用户文件、库文件</p>
<p>b. 按文件中数据的形式：源文件、目标文件、可执行文件</p>
<p>c. 按存取控制属性分类：只执行文件、只读文件、读写文件</p>
<p>d. 按文件的保护性质：只读文件、读写文件、可执行文件、不保护文件</p>
<p>e. 按文件的保护期限：临时文件、档案文件、永久文件</p>
<p>f. 按文件的存取方式：顺序存取文件、随机存取文件</p>
<p>g. 按设备的类型：磁盘文件、磁带文件、打印文件</p>
<p>h. 按文件的物理结构：连续文件、链接文件、索引文件</p>
<p>i. 按文件的内容（组织形式和处理方式）：普通文件、目录文件、特殊文件</p>
<p>j. 按文件的逻辑结构：流式文件、记录式文件</p>
<ol start="4">
<li>文件的逻辑结构</li>
</ol>
<p>a. 从用户使用的角度出发组织的文件，被称为是文件的逻辑结构，一类是有结构的文件，这是指由一个以上的记录构成的文件，故又称为记录式文件</p>
<p>b. 从文件的组织方式来分，可以分为顺序文件，索引文件，索引顺序文件</p>
<p>c. UNIX操作系统总是以流失作为文件的逻辑结构</p>
<ol start="5">
<li>文件的物理结构</li>
</ol>
<p>a. 文件按不同的组织方式在辅存上存放，就会得到不同的物理结构，文件的物理结构有时也称为文件的“存储结构”</p>
<p>b. 文件在辅存（外存）上可以有3种不同的存放方式：连续存放、链接块存放以及索引表存放</p>
<p>c. 对应地文件就有3种物理结构，分别叫做顺序结构，链接结构和索引结构，也叫作连续文件，串联文件，索引文件</p>
<ol start="6">
<li>存放方式</li>
</ol>
<p>a. 连续存放—连续文件</p>
<p>不足之处：</p>
<p>v 必须预先知道文件的最大长度</p>
<p>v 会造成磁盘碎片</p>
<p>b. 链接块存放—串联文件</p>
<p>不会因为磁盘碎片而浪费存储空间，但使用的指针要占去一些字节，每个磁盘块存储数据的字节数不再是2的幂，从而降低了系统的运行效率</p>
<p>c. 索引表存放—索引文件</p>
<ol start="7">
<li>文件的存取</li>
</ol>
<p>a. 顺序存取</p>
<p>b. 随机存取</p>
<ol start="8">
<li>磁盘空间的管理</li>
</ol>
<p>a. 磁盘是以块为单位进行分配的</p>
<p>b. 磁盘与内存之间是以磁盘块为信息传输的单位</p>
<p>c. 选定了块的大小，还要对它们进行管理，即要记住哪些已经分配，哪些仍然空闲。</p>
<p>d. 常采用的磁盘存储空间管理方案有：位示图，空闲块表，空闲块链</p>
<ol start="9">
<li>文件的操作：</li>
</ol>
<p>创建文件、删除文件、打开文件、关闭文件、读文件、写文件</p>
<ol start="10">
<li>系统是通过文件的目录来管理文件的</li>
</ol>
<p>文件目录也是一种数据结构，用于标识系统中的文件及其物理地址</p>
<ol start="11">
<li>为每一个文件开辟一个存储区，在它的里面记录着该文件的有关信息。</li>
</ol>
<p>我们把该存储区称为“文件控制块”（FCB） 也是一个目录项</p>
<p>随系统的不同，一个文件的FCB中所包含的内容及大小也不尽相同</p>
<p>包含内容：</p>
<p>Ø 文件名称</p>
<p>Ø 文件在辅存中存放的物理位置</p>
<p>Ø 文件的逻辑结构</p>
<p>Ø 文件的物理结构</p>
<p>Ø 文件的存取控制信息</p>
<p>Ø 文件管理信息</p>
<ol start="12">
<li>目录的层次结构</li>
</ol>
<p>如果把所有文件的FCB都登记在一个文件目录中，这样由文件名查文件目录项，直接就能够找到所需要的文件，那么就成这种文件目录为一级目录结构</p>
<p>a) 优点：</p>
<p>i. 简单，能实现目录管理中最基本的功能—按名存取</p>
<p>b) 缺点：</p>
<p>i. 查找速度慢，不允许重名，不便于实现文件共享</p>
<p>二级目录结构：</p>
<p>由“主目录”与“用户目录”二级构成，在主目录（根目录）中，每个目录项的内容只是给出文件主名以及它的目录所在的磁盘地址。在一个个用户目录中，才是由问价的呢FCB组成的目录，用户目录，实际上就是一级目录</p>
<ol>
<li>两级目录结构的优点：</li>
</ol>
<p>a. 提高了检索目录的速度</p>
<p>b. 在不同的文件目录中，可以使用相同的文件名</p>
<p>c. 不同用户还可使用不同的文件名访问系统中的同一个共享文件</p>
<ol start="2">
<li>缺点：</li>
</ol>
<p>a. 若一个用户可以拥有很多文件，则查找时间仍然很长</p>
<p>b. 用户无法对自己的文件进行再分类安排</p>
<ol start="3">
<li>树型目录结构</li>
</ol>
<p>允许每个用户可以拥有多个目录，即在用户目录的下面可以再分子目录，子目录的下面还可以再有子目录。但每个文件目录中，只能有一个根目录，每个文件和每个目录都只能有一个父目录</p>
<ol start="4">
<li>从根目录出发到具体文件所经过的各层名字，就构成了文件的“路径名”，从根目录出发的这个路径名，也称为文件的“绝对路径名”。</li>
</ol>
<p>文件的绝对路径名必须从根目录出发，且是唯一的，从分隔符开头</p>
<p>在UNIX系统中，路径名各部分之间是用“/”分隔</p>
<p>在MS-DOS系统中，路径各部分是用“\”分隔</p>
<p>在MVLTICS系统中，路径各部分之间是用“&gt;”分隔</p>
<p>在当前目录下的文件的路径名，称为文件的相对路径名</p>
<ol start="5">
<li>文件的“共享”是指一个文件可以被多个授权用户共同使用</li>
</ol>
<p>分两种：</p>
<p>Ø 任何时刻只允许一个用户使用共享文件</p>
<p>Ø 允许多个用户同时使用同一个共享文件，只进行读操作</p>
<h2 id="第六章-进程间的制约关系"><a href="#第六章-进程间的制约关系" class="headerlink" title="第六章 进程间的制约关系"></a>第六章 进程间的制约关系</h2><ol>
<li><p>在多道程序设计环境下，进程程序的执行具有并发性，在相同的前提条件下，两次执行的结果有可能不相同，使得一个进程对另一个进程的影响无法预测，在操作系统里把这种由于时间因素的影响而产生的错误称为：“与时间有关的错误”</p>
</li>
<li><p>进程间具有两种制约关系：互斥和同步</p>
</li>
</ol>
<p>a. 由于对共享资源的争夺，导致进程之间出现互斥关系</p>
<p>b. 由于对任务的协调工作，导致进城之间出现同步关系</p>
<ol start="3">
<li>把那些可以共享的资源（文件、队列、缓冲区、表格、变量······）统称为共享变量或临界资源</li>
</ol>
<p>与一个共享变量（或共享资源）交往的多个进程，为了保证它们各自运行结果的正确性，当其中的一个进程正在对该变量（临界资源）进行操作时，就不允许其他进程同时对它操作。进程的这种制约关系被称为“互斥”</p>
<ol start="4">
<li>注意（互斥进程）</li>
</ol>
<p>a. 作为具有互斥关系的进程，它的一部分程序可能用于内部的计算以及内部的数据处理等，那么只有设计共享变量的那一部分程序，才真正需要保证互斥地执行，把进程程序中“真正需要保证互斥执行”的那一段程序（或在每个进程中访问临界资源的那段代码）称为该进程的临界区（临界段）</p>
<p>b. 具有互斥关系的进程，并不关心对方的存在，即使对方不存在，自己也能够正确地运行</p>
<p>c. 具有互斥关系的那些进程程序中的临界区，虽然都是针对同一个共享变量的程序，但在其上执行的操作可以相同也可以不同</p>
<p>d. 进程的临界区是相对于某个共享变量而言的，不同共享变量的临界区之间，不存在互斥关系</p>
<p>信号量及其定义在信号量上的P、V操作：</p>
<ol>
<li>如何来保证进程在临界区执行的互斥性，由信号量及其定义在信号量上的P、V操作具体完成，但遵循如下规则</li>
</ol>
<p>a. 如果有若干个进程希望进入临界区时，至少应该允许一个进入，而不能谁也进不去</p>
<p>b. 每次只允许一个进程进入临界区</p>
<p>c. 进入临界区的进程不能无限期地把持临界区</p>
<ol start="2">
<li>同步</li>
</ol>
<p>a. 需要在某些点上协调相互的动作，谁先到达谁后到达是有顺序要求的</p>
<p>b. 这些进程都应该了解对方的工作，对方如果不存在，或任何一方单独运行，就会出现差错</p>
<p>c. 一方或双方的运行会直接地依赖于对方所产生的的信息，或发出的消息</p>
<ol start="3">
<li>一个进程运行到某一点时，除非合作进程已经完成了某种操作或发来了信息，否则就必须暂时等待那些操作的完成或信息的到来。</li>
</ol>
<p>进程间的这种关系被称为“同步”，暂停以取得同步的那一点称为“同步点”，需要等待一个进程完成的操作或发送的信息，称为“同步条件”</p>
<ol start="4">
<li>一个信号量的建立必须经过说明，即应该准确说明S的意义和初值（不能为负）</li>
</ol>
<p>每个信号量都有相应的队列，在建立信号量时，队列为空</p>
<p>可进行原子操作 P(wait)、V(signal)操作</p>
<ol start="5">
<li>信号量S上的P操作</li>
</ol>
<p>①　Vs = Vs-1，把当前信号量S的取值减1</p>
<p>②　若Vs &gt;= 0，则调用进程继续运行，若Vs &lt; 0，则调用进程由运行状态变为阻塞状态，到与该信号量有关的队列Vq上排队等待，直到其他进程在S上执行V操作将其释放为止</p>
<ol start="6">
<li>信号量S上的V操作</li>
</ol>
<p>①　Vs = Vs + 1，把当前信号量S的取值加1</p>
<p>②　若Vs &gt; 0，则调用进程继续执行，若Vs &lt;= 0，则先从与该信号量有关的队列Vq上摘下一个等待进程，让它从阻塞状态变为就绪状态，到就绪队列里排队，然后调用进程继续执行</p>
<p>注意：</p>
<p>a. 设置的信号量初值一定是一个非负的整数。而运行过程中，信号量的取值就不再受“非负”所限了</p>
<p>b. 只要进入了P(S)或V(S)，这两个动作就必须顺序地做完，中间不能被打断，为保证执行时的不可分割性，常采用关、开中断的方法来具体实现信号量上的P、V操作</p>
<p>c. 如果一个进程在做P操作后被阻塞，到关于信号量的队列上去排队等待，其含义是让进程的PCB到此队列上排队</p>
<ol start="7">
<li>用P、V操作实现资源分配</li>
</ol>
<p>做P操作即是申请一个资源，做V操作即是释放一个用完的资源</p>
<p>P操作后，若Vs &gt; 0时，Vs的值就是这种资源的剩余数</p>
<p> 若Vs &lt; 0时，表示现在已经没有资源可以分配，申请资源的进程只能被阻塞到申请队列Vq上去排队等待，Vs的绝对值表示提出资源请求，但没有分配到资源的进程个数</p>
<p>V操作后，若Vs &lt;= 0，表示申请资源的等待队列上有进程在等待该资源（表示V操作之前Vs &lt;= -1，即至少有一个进程在队列上等待使用该资源），所以将该队列上的一个进程摘下，让它到就绪队列中排队</p>
<p> 若Vs &gt; 0，表示V操作之前Vs &gt;= 0，即资源等待队列上没有进程在等待，只是收回了一个资源</p>
<ol>
<li><p>死锁：多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程将无法向前推进</p>
</li>
<li><p>定义：即指系统中若存在一组（至少两个或以上）进程，它们中的每一个都占用了某种资源而又都在等待其中另一个所占用的资源，这种等待永远不会结束，这就是死锁</p>
</li>
<li><p>产生死锁的4个必要条件</p>
</li>
</ol>
<p>a. 互斥条件：进程对所分配的资源进行排它性使用，即在一段时间内，某资源只能被一个进程占用</p>
<p>b. 部分分配条件（占用并等待）：进程由于申请不到所需要的资源而等待时，仍然占据着已经分配到的资源</p>
<p>c. 非剥夺条件：已经分配给进程的资源，别的进程不能强行夺取资源，只能被占用它的进程自己释放</p>
<p>d. 循环等待条件：在多个进程之间，由于资源的占有和请求关系，从而形成了一个循环等待的态势</p>
<ol start="4">
<li>处理死锁的方法：</li>
</ol>
<p>a. 预防死锁：破坏产生死锁的4个必要条件之一，使系统不具备产生思索的条件</p>
<p>b. 忽略死锁：任凭死锁出现，当系统中出现死锁时，就将系统重新启动</p>
<p>c. 避免死锁：在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而可以避免死锁</p>
<p>d. 检测死锁并恢复：在死锁发生后，采取相应措施加以恢复。如：撤销一些进程，回收它们的资源，将它们分配给已处于阻塞状态的进程，使其继续执行</p>
<ol start="5">
<li>预防死锁：</li>
</ol>
<p>a. 互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证</p>
<p>b. 破坏占用并等待条件：所有进程在开始运行之前，必须一次性地申请其在整个过程中所需要的全部资源，一次性分配</p>
<p>c. 破坏“分剥夺条件”：当进程提出新的资源请求得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请</p>
<p>d. 破坏循环等待条件：将系统中的所有资源进行统一编号，进程按编号的顺序，由小到大提出对资源使用的申请</p>
<ol start="6">
<li>在信号量上的P、V操作，可以看作是进程间的一种通信方式，这种通信并不在进程间真正交换信息，而只是双方事先的一种约定。因此，用P、V操作实现的通信，称为进程间的一种低级通信</li>
</ol>
<p>为了使进程间能够真正交换数据，操作系统备有高级通信命令，提供给用户在程序一级使用</p>
<p>高级进程通信分为直接通信和间接通信两种方式</p>
<p>间接通信是指通过信箱来传递消息</p>

      </section>
      <section class="extra">
        
        
        
        
  <nav class="nav">
    <a href="/2021/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><i class="iconfont iconleft"></i></a>
    <a href="/2021/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
    <div class="btn" id="comments-btn">查看评论</div>
  
  
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<div id="gitalk" class="gitalk"></div>
<script defer src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  window.onload = function () {
    var gitalk = new Gitalk({
      clientID: 'a16bdc09910ca579ff66',
      clientSecret: '086f27f5afd7d2a31a81274b510ee927003db357',
      id: window.location.pathname,
      repo: 'pikapi111.github.io',
      owner: 'pikapi111',
      admin: 'pikapi111'
    });
    if ( true ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        gitalk.render('gitalk');
      });
    } else {
      gitalk.render('gitalk');
    }
  }
</script>

</section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-text">第一章 操作系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A7%8D%E7%B1%BB%EF%BC%9A"><span class="toc-text">操作系统的种类：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%A4%84%E7%90%86%E6%9C%BA%E7%AE%A1%E7%90%86"><span class="toc-text">第二章 处理机管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86%EF%BC%9A"><span class="toc-text">作业管理：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-text">第三章 存储管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86"><span class="toc-text">第四章 设备管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-text">第五章 文件管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E5%88%B6%E7%BA%A6%E5%85%B3%E7%B3%BB"><span class="toc-text">第六章 进程间的制约关系</span></a></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=1079332052 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="https://github.com/pikapi111 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= " 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:1079332052@qq.com"
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont iconmail"></i>
      </a></div>
  
    <div class="footer-copyright">歪比巴卜</div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>








<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>